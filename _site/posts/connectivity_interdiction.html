<!doctype html>
<html lang="en">

<head>
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>talldoor - Vertex and Edge Connectivity Interdiction</title>
    <link rel="stylesheet" href="../katex/katex.min.css">
    <script defer src="../katex/katex.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontURL: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                }
            }
        };
    </script>
    <script src="../mathjax/tex-chtml.js" defer></script>

</head>

<body>
    <div class="navbar-space">
        
        <!-- A table of contents on the left side, but only for screens
                that are big enough -->
        <div id="contents-big">
            <p class="mini-header">Contents <a id="up-arrow" href="#">↑</a></p>
            <ul>
<li><a href="#checking-k-vertex-connectivity">Checking <span class="math inline">\(k\)</span>-vertex connectivity</a>
<ul>
<li><a href="#minimum-cut-for-edge-connectivity">Minimum cut for edge connectivity</a></li>
<li><a href="#minimum-cut-for-vertex-connectivity">Minimum cut for vertex connectivity</a></li>
</ul></li>
<li><a href="#edge-connectivity-interdiction">(Edge) Connectivity interdiction</a>
<ul>
<li><a href="#reweighting">Reweighting</a></li>
<li><a href="#more-on-normalized-min-cut">More on normalized min-cut</a></li>
</ul></li>
</ul>
        </div>
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Vertex and Edge Connectivity Interdiction</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on February 13, 2025
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'alg'." href="../tags/alg.html" rel="tag">alg</a>, <a title="All pages tagged 'combinatorics'." href="../tags/combinatorics.html" rel="tag">combinatorics</a>, <a title="All pages tagged 'optimization'." href="../tags/optimization.html" rel="tag">optimization</a>
        
    </div>    
    <section>
        <p>As a natural generalization of min-cut, the following problem seems
interesting to me,</p>
<div id="prob1" class="theorem-environment Problem" data-index="1" type="Problem">
<span class="theorem-header"><span class="type">Problem</span><span class="index">1</span></span>
<p>Given a graph <span class="math inline">\(G=(V,E)\)</span> and an
integer <span class="math inline">\(k\)</span>, find the minimum edge
set whose removal breaks <span class="math inline">\(k\)</span>-vertex
connectivity?</p>
</div>
<p>Alternatively, one can consider a closely related version of <a href="#prob1" title="Problem 1">Problem 1</a>,</p>
<div id="prob2" class="theorem-environment Problem" data-index="2" type="Problem">
<span class="theorem-header"><span class="type">Problem</span><span class="index">2</span></span>
<p>Given a graph <span class="math inline">\(G=(V,E)\)</span> and an
integer <span class="math inline">\(k\)</span>, find an edge set <span class="math inline">\(F\subset E\)</span> with size at most <span class="math inline">\(k\)</span> whose removal minimizes the vertex
connectivity of <span class="math inline">\(G-F\)</span>.</p>
</div>
<p>This problem can be called the “vertex connectivity interdiction”.
One can also consider the “algebraic connectivity interdiction” (the
second smallest eigen value of the Laplacian matrix).</p>
<blockquote>
<p>In fact, I think <a href="#prob2" title="Problem 2">Problem 2</a> is
not well motivated. I am interested in it since there may be connections
between breaking vertex connectivity and breaking combinatorial
rigidity. However, it seems strange to consider interdiction problems on
<strong>edge</strong> set for <strong>vertex</strong> connectivity. For
vertex removal, this problem is easy (by splitting vertex and finding
mincut).</p>
</blockquote>
<h1 data-number="1" id="checking-k-vertex-connectivity"><span class="header-section-number">1</span> Checking <span class="math inline">\(k\)</span>-vertex connectivity</h1>
<p>Checking if a given graph is <span class="math inline">\(k\)</span>-vertex connected <a href="https://en.wikipedia.org/wiki/K-vertex-connected_graph#Computational_complexity">can
be done in polynomial time</a>. By <a href="https://en.wikipedia.org/wiki/Menger%27s_theorem">Menger’s
theorem</a> we need to check if for every vertex pair <span class="math inline">\((s,t)\)</span> there are at least <span class="math inline">\(k\)</span> vertex disjoint paths (excluding <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>) connecting <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. The number of vertex disjoint paths
between <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> can be easily computed through max
flow.
<!-- Duplicate every vertex except $s$ and $t$ and connect an directed edge with capacity 1 between every pair of new vertices. The capacity is 1 for all edges.  -->
We replace every internal vertex <span class="math inline">\(v\)</span>
with two copies <span class="math inline">\(v_{in}\)</span> and <span class="math inline">\(v_{out}\)</span> and add directed edges from <span class="math inline">\(N(v)\)</span> to <span class="math inline">\(v_{in}\)</span> and from <span class="math inline">\(v_{out}\)</span> to <span class="math inline">\(N(v)\)</span> with capacity 1. The integral max
flow is the number of internally disjoint paths between <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. Since the constraint matrix of flow
problems is TU, maximizing the flow gives us the vertex
connectivity.</p>
<blockquote>
<p>Instead of computing the flow for every pair, if we want one flow
that gets the demand for every vertex pair <span class="math inline">\((i&lt;j)\)</span>, the problem becomes much
harder. This is <a href="https://en.wikipedia.org/wiki/Multi-commodity_flow_problem">Multi-commodity
flow problem</a>.</p>
</blockquote>
<p>Currently the fastest algorithm for computing vertex connectivity is
<del><span class="citation" data-cites="HENZINGER2000222">[<a href="#ref-HENZINGER2000222" role="doc-biblioref">1</a>]</span></del> <a href="https://dl.acm.org/doi/10.1145/3406325.3451088" class="uri">https://dl.acm.org/doi/10.1145/3406325.3451088</a>. There is
a nice table for a summary of connectivity related algorithms.</p>
<figure>
<img src="../images/vertex_connectivity_cut/table.png" alt="image courtesy of Abdol–Hossein Esfahanian. link" />
<figcaption aria-hidden="true">image courtesy of Abdol–Hossein
Esfahanian. <a href="http://www.cse.msu.edu/~esfahani/book_chapter/Graph_connectivity_chapter.pdf">link</a></figcaption>
</figure>
<p><span class="citation" data-cites="HENZINGER2000222">[<a href="#ref-HENZINGER2000222" role="doc-biblioref">1</a>]</span> appears
in the last line. The conference version was published on FOCS96.</p>
<h2 data-number="1.1" id="minimum-cut-for-edge-connectivity"><span class="header-section-number">1.1</span> Minimum cut for edge
connectivity</h2>
<p>Finding the minimum edge set whose removal breaks the <span class="math inline">\(k\)</span>-edge connectivity is “easy”. It is
known that the global min-cut is the edge connectivity number. <del>Thus
we can simply compute the min-cut and remove any number of the edges as
needed.</del> — which is not true! For unit edge weights this problem is
indeed that easy. However, for general weights edge-connectivity cut is
not as easy as min-cut. This problem is actually the unit cost version
of connectivity interdiction. See next section for more details.</p>
<h2 data-number="1.2" id="minimum-cut-for-vertex-connectivity"><span class="header-section-number">1.2</span> Minimum cut for vertex
connectivity</h2>
<p>With the knowledge of how to compute vertex connectivity, we try to
compute the minimum cut for <span class="math inline">\(k\)</span>-vertex connectivity in a similar way.
First we can find the vertex pair <span class="math inline">\((s,t)\)</span> with the smallest number of
internally disjoint paths. Note that we are dealing with the modified
graph when computing the vertex connectivity number with flow. Hence the
min-cut may contain edges that are not in the original graph, i.e., the
edges connecting <span class="math inline">\(v_{in}\)</span> and <span class="math inline">\(v_{out}\)</span>. For example, consider a graph
where every edge has multiplicities 2. The min-cut reported by the flow
algorithm should only contain edges between <span class="math inline">\(v_{in}\)</span> and <span class="math inline">\(v_{out}\)</span>.</p>
<p>There is a <a href="https://lemon.cs.elte.hu/egres/open/Node-connectivity">list</a> of
open problems on vertex(node) connectivity. I guess <a href="#prob1" title="Problem 1">Problem 1</a> is NP-hard but cannot prove it. However,
the capacitated version of <a href="#prob2" title="Problem 2">Problem
2</a> and <a href="#prob1" title="Problem 1">Problem 1</a> is hard.
Given a graph <span class="math inline">\(G=(V,E)\)</span> and edge
weights <span class="math inline">\(w:E\to \Z_{\geq 0}\)</span> and
costs <span class="math inline">\(c:E\to \Z_{\geq 0}\)</span> and a
budget <span class="math inline">\(b\geq 0\)</span>, find edge set <span class="math inline">\(F\subset E\)</span> such that <span class="math inline">\(c(F)\leq b\)</span> and such that removing <span class="math inline">\(F\)</span> minimizes the vertex connectivity of
<span class="math inline">\(G-F\)</span>. Similar to the edge
connectivity case (which will be shown in the next section), if the cost
<span class="math inline">\(c\)</span> is nontrivial then kanpsack is a
special case of this problem. (Consider <span class="math inline">\(G=K_n\)</span> for some large <span class="math inline">\(k\)</span>. Pick a <span class="math inline">\(K_{n-1}\)</span> in <span class="math inline">\(G\)</span> and set the cost of edges in <span class="math inline">\(K_{n-1}\)</span> to infinity.) How hard is <a href="#prob2" title="Problem 2">Problem 2</a> if costs are trivial?</p>
<h1 data-number="2" id="edge-connectivity-interdiction"><span class="header-section-number">2</span> (Edge) Connectivity
interdiction</h1>
<p>If we replace the vertex connectivity in <a href="#prob2" title="Problem 2">Problem 2</a> with edge connectivity, then the problem
is called connectivity interdiction and was first studied by Zenklusen
<span class="citation" data-cites="zenklusen_connectivity_2014">[<a href="#ref-zenklusen_connectivity_2014" role="doc-biblioref">2</a>]</span>.</p>
<div id="prob3" class="theorem-environment Problem" data-index="3" type="Problem">
<span class="theorem-header"><span class="type">Problem</span><span class="index">3</span></span>
<p>Given a graph <span class="math inline">\(G=(V,E)\)</span> and costs
<span class="math inline">\(c:E\to \Z_+\)</span> and weights <span class="math inline">\(w:E\to \Z_+\)</span> and a budget <span class="math inline">\(B\in \Z_+\)</span>, find the edge set <span class="math inline">\(R\)</span> such that <span class="math inline">\(c(R)\leq B\)</span> and that minimizes the <span class="math inline">\(w\)</span>-weighted min cut in <span class="math inline">\((V,E\setminus R)\)</span>.</p>
</div>
<p>The <a href="https://arxiv.org/abs/2506.17008v1">Fault-Tolerant
Path</a> problem (FTP) seems sililar to <a href="#prob3" title="Problem 3">Problem 3</a>. In FTP problem, we are given a
edge-weighted directed graph <span class="math inline">\(G=(V,E)\)</span>, a subset <span class="math inline">\(U \subseteq E\)</span> of vulnerable edges, two
vertices <span class="math inline">\(s,t\in V\)</span> and integers
<span class="math inline">\(k\)</span> and <span class="math inline">\(\ell\)</span>. The task is to decide whether there
exists a subgraph <span class="math inline">\(H\)</span> of <span class="math inline">\(G\)</span> with total cost at most <span class="math inline">\(ℓ\)</span> such that, after the removal of any
<span class="math inline">\(k\)</span> vulnerable edges, <span class="math inline">\(H\)</span> still contains an <span class="math inline">\(s\)</span>-<span class="math inline">\(t\)</span>-path. The problem degenerates into
finding <span class="math inline">\(k\)</span>-edge connected spanning
subgraph if the set of vulnerable edges is <span class="math inline">\(E\)</span>.</p>
<p>A recent paper <span class="citation" data-cites="vygen_fptas_2024">[<a href="#ref-vygen_fptas_2024" role="doc-biblioref">3</a>]</span> gives an FPTAS for the problem. Here
I try to develop the intuition since I have never seen an algorithm
based on reweighting edges this complicated and ingenious.</p>
<p>First one can see that the optimal solution can always be a subset of
edges in a cut of <span class="math inline">\(G\)</span>. This is
because if the optimal solution <span class="math inline">\(R^*\)</span>
contains any edge not in the cut, we can safely delete it from <span class="math inline">\(R^*\)</span>. Thus the optimal solution is indeed
a pair <span class="math inline">\((C^*,R^*\subset C^*)\)</span>. The
authors call this problem the <em><span class="math inline">\(b\)</span>-free min-cut problem</em> (<span class="math inline">\(b\)</span> is the budget and we are allowed to
pick edges for free in the “mincut” with total weight at most <span class="math inline">\(b\)</span>).</p>
<p>So the goal is to find a FPTAS for the <span class="math inline">\(b\)</span>-free mincut problem. The problem is
hard since it contains knapsack as a special case. (Consider a graph
with many parallel edges and only 2 vertices.) However, it is known that
there is a <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15854-f05/www/scribe/lec10.pdf">FPTAS
for knapsack</a>. If we know part of the optimal solution, i.e., <span class="math inline">\(C^*\)</span>, we can use the FPTAS for knapsack to
find the optimal <span class="math inline">\(R^*\)</span>.</p>
<p>At this stage, if there is a hint suggesting reweighting the edges, I
would guess that <span class="math inline">\(C^*\)</span> is exactly (or
close to) the min-cut of the re-weighted graph. Based on this idea I
would also guess that, although the connectivity interdiction problem
(<span class="math inline">\(b\)</span>-free min-cut) is NP-hard, <span class="math inline">\(C^*\)</span> can be computed in polynomial time.
In other words, the intractable part is solving the knapsack in <span class="math inline">\(C^*\)</span>. This statement seems reasonable,
since this problem is know to be in P for unit costs and in that case
the kanpsack is trivial. Let’s assume that my guess is correct and work
on the reweighting part.</p>
<h2 data-number="2.1" id="reweighting"><span class="header-section-number">2.1</span> Reweighting</h2>
<p>There is a <a href="https://sarielhp.org/teach/notes/aprx/lec/18_reweight.pdf">chapter
on reweighting</a> in Sariel Har-Peled’s gemetric approximation book(not
quite the same as the reweighting technique in <span class="citation" data-cites="vygen_fptas_2024">[<a href="#ref-vygen_fptas_2024" role="doc-biblioref">3</a>]</span>). Is reweighting a common technique
for designing approximation algorithms?</p>
<p>One possible weight function is setting <span class="math inline">\(w(e)=0\)</span> for all <span class="math inline">\(e\in R^*\)</span>… However, this is cheating since
we assume that <span class="math inline">\(R^*\)</span> is the hard
part. So now we need to find a weight function such that the following
holds,</p>
<ol type="1">
<li>The min-cut of the re-weighted graph is close to <span class="math inline">\(C^*\)</span>.</li>
<li>Computing the weight function takes polynomial time.</li>
</ol>
<p>From the “cheating” example we can see that knowing <span class="math inline">\(R^*\)</span> does help but computing <span class="math inline">\(R^*\)</span> is hard. So maybe we can find a
slightly worse weight function which is a lot easier to compute. So it
seems like we are making a trade-off between how close the global
min-cut of the re-weighted graph is to <span class="math inline">\(C^*\)</span>, and how much time is needed to
compute this weight function. This paper indeed does a great job in
finding such a balance. I sent an email to one of the authors to ask for
the intuition behind the reweighting but did not get a real answer. They
suggested reading <span class="citation" data-cites="zenklusen_connectivity_2014">[<a href="#ref-zenklusen_connectivity_2014" role="doc-biblioref">2</a>]</span>. Zenklusen did almost the same
thought experiment as above. Instead of using reweighting, he indirectly
enumerated <span class="math inline">\(R^*\)</span>. Consider the unit
cost case for example. If the optimal cut <span class="math inline">\(C^*\)</span> is given, the interdicted edges <span class="math inline">\(R^*\)</span> will be those <span class="math inline">\(b\)</span> edges in <span class="math inline">\(C^*\)</span> with heaviest weights. We cannot
directly enumerate <span class="math inline">\(R^*\)</span> since it
still takes exponential time. What we can enumerate is a lowerbound of
the weight of edges in <span class="math inline">\(R^*\)</span>. Set all
edges with weights exceeding this lowerbound to be in <span class="math inline">\(R^*\)</span> and find global min-cut with
additional budget constraint on these edges. Then we have only <span class="math inline">\(m\)</span> lowerbound to enumerate and the
budgeted min-cut can be computed fast. For general costs, he enumerated
the set of <span class="math inline">\({1}/{\varepsilon}\)</span> edges
with heaviest weights in <span class="math inline">\(C^*\)</span>.</p>
<p>The plan is to figure out how did the authors come up with the weight
function in <span class="citation" data-cites="vygen_fptas_2024">[<a href="#ref-vygen_fptas_2024" role="doc-biblioref">3</a>]</span> and if
it is possible to find a better weight function.</p>
<p>The key part is the following new problem called normilized
min-cut,</p>
<div id="normmincut" class="theorem-environment Problem" data-index="4" type="Problem" title="Normalized min-cut">
<span class="theorem-header"><span class="type">Problem</span><span class="index">4</span><span class="name">Normalized
min-cut</span></span>
<p>Given a problem instance of connectivity interdiction, find a cut
<span class="math inline">\(C\)</span> and its subset <span class="math inline">\(F\subset C\)</span> s.t. <span class="math inline">\(0\leq c(F)\leq b\)</span> and <span class="math inline">\(\frac{w(C\setminus F)}{b+1-c(F)}\)</span> is
minimized.</p>
</div>
<p><del>I have been thinking for a while how this problem is involved
but have no clue. However, it does work…</del> The weight function is
defined based on an estimation of <a href="#normmincut" title="Problem 4">Problem 4</a>. The authors claim that the optimal
solution to b-free min-cut problem is a 2-approximate min-cut of the
reweighted graph. Then they enumerate all 2-approximate min-cut of the
reweighted graph and use the FPTAS alg for knapsack on each cut to find
a <span class="math inline">\((1+\epsilon)\)</span>-approx solution.</p>
<h2 data-number="2.2" id="more-on-normalized-min-cut"><span class="header-section-number">2.2</span> More on normalized min-cut</h2>
<p>If one slightly modifies lemmas in section 2 in <span class="citation" data-cites="vygen_fptas_2024">[<a href="#ref-vygen_fptas_2024" role="doc-biblioref">3</a>]</span>, there
are some interesting properties. Let <span class="math inline">\(\tau\)</span> be the value of the optimal
normalized min-cut (in <span class="citation" data-cites="vygen_fptas_2024">[<a href="#ref-vygen_fptas_2024" role="doc-biblioref">3</a>]</span> <span class="math inline">\(\tau\)</span> is an estimation of the optimum) and
define <span class="math inline">\(\tilde{w}_\tau\)</span> accordingly.
Then one can prove that the global min cut in <span class="math inline">\((G,\tilde{w}_\tau)\)</span> is exactly the optimal
cut in the normalized min-cut of <span class="math inline">\((G,w)\)</span> (slightly modify lemma3 to see
this). Also the value of min-cut in <span class="math inline">\((G,\tilde{w}_\tau)\)</span> is <span class="math inline">\(\tau(b+1)\)</span>.</p>
<p>For unit cost, the optimum of normalized min-cut can be computed
using the same complexity as connectivity interdiction (ignoring polylog
factors) <span class="citation" data-cites="chalermsook_approximating_2022">[<a href="#ref-chalermsook_approximating_2022" role="doc-biblioref">4</a>]</span>. Consider the sequence <span class="math inline">\(\set{\lambda_i=\frac{\min_{|F|\le i} w(C\setminus
F)}{b+1-i}}\)</span>. If this is unimodal, <span class="math inline">\(O(\log b)\)</span> calls of connectivity
interdiction algorithm should be sufficient. (Note that <span class="math inline">\(b\)</span> is at most <span class="math inline">\(m\)</span> since costs are unit.) However, one can
easily see that this sequence is not unimodal. Thus I don’t quite
believe this claim.</p>
<details>
<summary>
Comments on <span class="citation" data-cites="vygen_fptas_2024">[<a href="#ref-vygen_fptas_2024" role="doc-biblioref">3</a>]</span>
</summary>
<p>After reading <span class="citation" data-cites="chalermsook_approximating_2022">[<a href="#ref-chalermsook_approximating_2022" role="doc-biblioref">4</a>]</span>, I finally know why the authors use
<a href="#normmincut" title="Problem 4">Problem 4</a> to solve
connectivity interdiction. Almost all techniques they used are directly
from <span class="citation" data-cites="chalermsook_approximating_2022">[<a href="#ref-chalermsook_approximating_2022" role="doc-biblioref">4</a>]</span>. Read section 2 of <span class="citation" data-cites="chalermsook_approximating_2022">[<a href="#ref-chalermsook_approximating_2022" role="doc-biblioref">4</a>]</span> until 2.2, you know almost everything
needed for a FPTAS solving connectivity interdiction. In fact, the
authors cite <span class="citation" data-cites="chalermsook_approximating_2022">[<a href="#ref-chalermsook_approximating_2022" role="doc-biblioref">4</a>]</span> in their paper,</p>
<blockquote>
<p>In a recent paper of Chalermsook et el. [CHN+22] on survivable
network design, the same problem was first introduced (under a diﬀerent
name “minimum normalized free cut”) to deal with a certain boxing
constraint in the LPs. There, a special case of unit-edge costs is
actually solved as a technical necessity. To obtain an FPTAS in this
paper, we emphasize that we do not need to solve the normalized min-cut
problem per se, but rather we use its optimal solution as a certificate
in the analysis of the weight function <span class="math inline">\(\tilde{w}(i)\)</span> in Theorem 3.</p>
</blockquote>
<p>This paragraph is extremely misleading. There is no clearly
indication that very similar (in fact, almost identical) results are
proven [CHN+22]. Not to mention that the authors were somewhat avoiding
my question (in my opinion) about Normalized min-cut(see <a href="#reweighting">reweighting part</a>).</p>
<p>It was mentioned in a footnote of <span class="citation" data-cites="chalermsook_approximating_2022">[<a href="#ref-chalermsook_approximating_2022" role="doc-biblioref">4</a>]</span> that a general version of normalized
min-cut is used in <a href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol064-isaac2016/LIPIcs.ISAAC.2016.33/LIPIcs.ISAAC.2016.33.pdf">this
paper</a>, which in turn mentioned that normalized min-cut is an
ordinary subroutine in MWU frameworks. This IPCO paper’s writing style
is toxic and causes huge waste of readers’ time. I do not think this
paper still can be accepted by IPCO if reviewers and PCs notice its
relation with [CHN+22].</p>
</details>
<p>some notes <a href="https://gitea.talldoor.uk/sxlxc/edge_conn_interdiction">here</a></p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-HENZINGER2000222" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">M.R. Henzinger, S. Rao, H.N. Gabow, Computing
vertex connectivity: New bounds from old techniques, <em>Journal of
Algorithms</em>. 34 (2000) 222–250 <a href="https://doi.org/10.1006/jagm.1999.1055">https://doi.org/10.1006/jagm.1999.1055</a>.</div>
</div>
<div id="ref-zenklusen_connectivity_2014" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">R.
Zenklusen, Connectivity interdiction, <em>Operations Research
Letters</em>. 42 (2014) 450–454 <a href="https://doi.org/10.1016/j.orl.2014.07.010">10.1016/j.orl.2014.07.010</a>.</div>
</div>
<div id="ref-vygen_fptas_2024" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">C.-C. Huang, N. Obscura Acosta, S.
Yingchareonthawornchai, An <span>FPTAS</span> for
<span>Connectivity</span> <span>Interdiction</span>, in: <em>Integer
<span>Programming</span> and <span>Combinatorial</span>
<span>Optimization</span></em>, Springer Nature Switzerland, Cham, 2024:
pp. 210–223 <a href="https://doi.org/10.1007/978-3-031-59835-7_16">10.1007/978-3-031-59835-7_16</a>.</div>
</div>
<div id="ref-chalermsook_approximating_2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">P.
Chalermsook, C.-C. Huang, D. Nanongkai, T. Saranurak, P. Sukprasert, S.
Yingchareonthawornchai, Approximating
k-<span>Edge</span>-<span>Connected</span> <span>Spanning</span>
<span>Subgraphs</span> via a <span>Near</span>-<span>Linear</span>
<span>Time</span> <span>LP</span> <span>Solver</span>, in: <em>49th
<span>International</span> <span>Colloquium</span> on
<span>Automata</span>, <span>Languages</span>, and
<span>Programming</span> (<span>ICALP</span> 2022)</em>, Schloss
Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl, Germany, 2022: pp.
37:1–37:20 <a href="https://doi.org/10.4230/LIPIcs.ICALP.2022.37">10.4230/LIPIcs.ICALP.2022.37</a>.</div>
</div>
</div>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source on Github</a>.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="https://licensebuttons.net/l/by-sa/4.0/88x31.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>