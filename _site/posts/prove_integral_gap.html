<!doctype html>
<html lang="en">

<head>
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>Proving integrality gap for LPs</title>
    <link rel="preload" href="../fonts/FiraSans-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-Italic.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/FiraSans-SemiBold.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/IosevkaCustom-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <script defer src="../css/pangu.simple.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontURL: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
        <!-- A table of contents on the left side, but only for screens
                that are big enough -->
        <div id="contents-big">
            <p class="mini-header">Contents <a id="up-arrow" href="#">â†‘</a></p>
            <ul>
<li><a href="#counting">Counting</a>
<ul>
<li><a href="#tree-packing-theorem">tree packing theorem</a></li>
<li><a href="#k-cut"><span class="math inline">\(k\)</span>-cut</a></li>
</ul></li>
<li><a href="#rounding">Rounding</a></li>
<li><a href="#intermediate-problem">Intermediate problem</a>
<ul>
<li><a href="#minimum-k-edge-connected-spanning-subgraph">minimum <span class="math inline">\(k\)</span>-edge-connected spanning subgraph</a></li>
</ul></li>
<li><a href="#notes">Notes</a></li>
</ul>
        </div>
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">Proving integrality gap for LPs</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on April  1, 2025
        
            by Yu Cong
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'optimization'." href="../tags/optimization.html" rel="tag">optimization</a>, <a title="All pages tagged 'LP'." href="../tags/LP.html" rel="tag">LP</a>
        
    </div>    
    <section>
        <p>Proving integral gap of linear programs are generally hard. It would
be great if one can classify LPs with a constant gap. It is known that
deciding whether a polyhedron is integral is co-NP-complete <span class="citation" data-cites="ding_complexity_2008">[<a href="#ref-ding_complexity_2008" role="doc-biblioref">1</a>]</span>. I
am interested in techniques for proving constant upperbound for integral
gaps of linear programs.</p>
<p>Here are some methods with examples that I read in books and
papers.</p>
<h1 data-number="1" id="counting"><span class="header-section-number">1</span> Counting</h1>
<p>Just do the counting.</p>
<h2 data-number="1.1" id="tree-packing-theorem"><span class="header-section-number">1.1</span> tree packing theorem</h2>
<div class="theorem-environment Example" data-index="1" type="Example">
<span class="theorem-header"><span class="type">Example</span><span class="index">1</span></span>
<p>Consider the following integer program on graph <span class="math inline">\(G=(V,E)\)</span>, <span class="math display">\[\begin{align*}
\lambda=\min&amp;   &amp;  \sum_{e\in E} x_e&amp;       &amp;   &amp; \\
s.t.&amp;           &amp;  \sum_{e\in T} x_e&amp;\ge
1  &amp;   &amp;\forall T\in \mathcal T \\
&amp;              &amp;  x_e&amp;\in\Z_{\ge
0}        &amp;   &amp;\forall e\in E
\end{align*}\]</span></p>
<p>where <span class="math inline">\(\mathcal T\)</span> is the set of
spanning tree in <span class="math inline">\(G\)</span>. Let <span class="math inline">\(\tau\)</span> be the optimum of the linear
relaxation.</p>
</div>
<div class="theorem-environment Theorem" data-index="2" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">2</span></span>
<p><span class="math inline">\(\lambda \le 2 \tau\)</span>.</p>
</div>
<p>Note that the optimum solution to <span class="math inline">\(\lambda\)</span> is the minimum cut in <span class="math inline">\(G\)</span>. It is known that <span class="math inline">\(\tau\)</span> is the maximum tree packing in <span class="math inline">\(G\)</span> and <span class="math inline">\(\tau=\min\limits_{F\subset
E}\frac{|E-F|}{r(E)-r(F)}\)</span>, where <span class="math inline">\(r\)</span> is the rank of the graphic matroid on
<span class="math inline">\(G\)</span> <span class="citation" data-cites="Schrijver2004">[<a href="#ref-Schrijver2004" role="doc-biblioref">2</a>]</span>. Then the proof is a simple counting
argument.</p>
<div class="theorem-environment Proof" type="Proof">
<span class="theorem-header"><span class="type">Proof</span></span>
<p>If <span class="math inline">\(G\)</span> is not connected, Let <span class="math inline">\(G_1,...,G_k\)</span> be the set of components in
<span class="math inline">\(G\)</span>. One can easily see that the gap
of <span class="math inline">\(G\)</span> is at most the largest gap of
the components. Thus considering connected graphs is sufficient.</p>
<p>We fix <span class="math inline">\(F^*\in \arg\min
\frac{|E-F^*|}{r(E)-r(F^*)}\)</span>. <span class="math inline">\(r(E)-r(F^*)\)</span> must be positive and <span class="math inline">\(E-F^*\)</span> is a cut in <span class="math inline">\(G\)</span>. Suppose <span class="math inline">\(E-F^*\)</span> is any cut in <span class="math inline">\(G\)</span>. Let <span class="math inline">\(S_1,...,S_h\)</span> be components in <span class="math inline">\(G\setminus (E\setminus F^*)\)</span>. For any
<span class="math inline">\(S_i\)</span>, the set of edges with exactly
one endpoint in <span class="math inline">\(S_i\)</span> (denoted by
<span class="math inline">\(e[S_i]\)</span>) must contain a cut of <span class="math inline">\(G\)</span> since the <span class="math inline">\(G\)</span> is connected. One can see that <span class="math inline">\(2|E-F^*|=\sum_i |e[S_i]|\ge \lambda
(r(E)-r(F))\)</span> since the number of component is <span class="math inline">\(r(E)-r(F^*)\)</span>.</p>
</div>
<h2 data-number="1.2" id="k-cut"><span class="header-section-number">1.2</span> <span class="math inline">\(k\)</span>-cut</h2>
<div class="theorem-environment Example" data-index="3" type="Example">
<span class="theorem-header"><span class="type">Example</span><span class="index">3</span></span>
<p><span class="math display">\[\begin{align*}
\lambda_k=\min&amp;   &amp;  \sum_{e\in E}
c(&amp;e)x_e       &amp;   &amp; \\
s.t.&amp;             &amp;  \sum_{e\in T} x_e&amp;\ge
k  &amp;   &amp;\forall T\in \mathcal T \\
&amp;                &amp;  0\le x_e&amp;\le
1        &amp;   &amp;\forall e\in E
\end{align*}\]</span></p>
</div>
<div class="theorem-environment Theorem" data-index="4" type="Theorem">
<span class="theorem-header"><span class="type">Theorem</span><span class="index">4</span></span>
<p>The integral gap of <span class="math inline">\(\lambda_k\)</span> is
at most <span class="math inline">\(2(1-1/n)\)</span>.</p>
</div>
<p>The proof is in section 5 of <span class="citation" data-cites="chekuri_lp_2020">[<a href="#ref-chekuri_lp_2020" role="doc-biblioref">3</a>]</span>. Here is a sketch.</p>
<p>For <span class="math inline">\(k\)</span>-cut we cannot use the
simple counting argument since the dual LP is not a tree packing. (the
LP dual needs extra variables <span class="math inline">\(z_e\)</span>
for constraints <span class="math inline">\(x_e\le 1\)</span>.) However,
it is still easy to find an upperbound for the integral optimum. If we
sort vertices in increasing order of their degree, that is, <span class="math inline">\(\mathop{\mathrm{deg}}(v_1)\le \dots \le
\mathop{\mathrm{deg}}(v_n)\)</span>, then <span class="math inline">\(\sum_{i=1}^{k-1}
\mathop{\mathrm{deg}}(v_i)\)</span> is an upperbound for integral <span class="math inline">\(k\)</span>-cut. Then it is easy to prove that if
the optimal solution <span class="math inline">\(x^*\)</span> to <span class="math inline">\(\lambda_k\)</span> is fully fractional (<span class="math inline">\(x_e^*\in (0,1)\)</span> for all <span class="math inline">\(e\in E\)</span>), then the gap is <span class="math inline">\(2(1-1/n)\)</span>. The proof is to use
complemantary slackness conditions, i.e., <span class="math inline">\(z_e=0,\sum_{e\in T}y_T=c(e)\;\forall e\in
E\)</span>. The following observations reduce general <span class="math inline">\(x^*\)</span> to fully fractional case:</p>
<ol type="1">
<li>Given an optimal solution <span class="math inline">\(x^*\)</span>,
let <span class="math inline">\(X\)</span> be the set of edges <span class="math inline">\(e\)</span> such that <span class="math inline">\(x_e^*=0\)</span>. The optimum to <span class="math inline">\(\lambda_k\)</span> on <span class="math inline">\(G/X\)</span> is the same as on <span class="math inline">\(G\)</span>.</li>
<li>For an optimal solution <span class="math inline">\(x^*\)</span>,
let <span class="math inline">\(F\)</span> be the set of edges <span class="math inline">\(e\)</span> such that <span class="math inline">\(x_e^*=1\)</span>. Let <span class="math inline">\(x^*|_{E-F}\)</span> be the restriction of <span class="math inline">\(x^*\)</span> to <span class="math inline">\(E-F\)</span>. <span class="math inline">\(x^*|_{E-F}\)</span> is a fully fractional optimum
solution to <span class="math inline">\(\lambda_k\)</span>. (Some
discussions are needed for the number of components in <span class="math inline">\(G\setminus F\)</span>. The reduction can be done
using the fact that if <span class="math inline">\(1\leq
\frac{\lambda}{\sigma}\le c\)</span> then <span class="math inline">\(1\le \frac{\lambda+k}{\sigma+k}\le
c\)</span>.)</li>
</ol>
<h1 data-number="2" id="rounding"><span class="header-section-number">2</span> Rounding</h1>
<p>A constant factor approximation algorithm based on LP may imply a
constant upperbound of the corresponding LP.</p>
<p>Examples:</p>
<ol type="1">
<li>vertex cover and set cover <a href="https://courses.grainger.illinois.edu/cs598csc/sp2011/Lectures/lecture_4.pdf">uiuc
cs598csc</a></li>
<li>facility location <a href="https://www.cs.dartmouth.edu/~deepc/LecNotes/Appx/5.%20Deterministic%20Rounding%20for%20Facility%20Location.pdf">Dartmouth</a></li>
<li>CKR relaxation of multiway cut <a href="https://courses.grainger.illinois.edu/cs583/sp2018/Notes/multiwaycut-ckr.pdf">uiuc
cs583</a></li>
<li>uniform labeling <a href="https://www.cs.cornell.edu/home/kleinber/focs99-mrf.pdf">FOCSâ€™99</a>
basically multiway cut with assignment cost.</li>
</ol>
<h1 data-number="3" id="intermediate-problem"><span class="header-section-number">3</span> Intermediate problem</h1>
<p>I read about this in <span class="citation" data-cites="chalermsook_approximating_2022">[<a href="#ref-chalermsook_approximating_2022" role="doc-biblioref">4</a>]</span>. Suppose that we want to prove
constant gap for <span class="math inline">\(LP1\)</span>. The idea is
to find another LP (say <span class="math inline">\(LP2\)</span>) which
is integral or has constant gap and to prove that <span class="math inline">\(\frac{\mathop{\mathrm{OPT}}(IP1)}{\mathop{\mathrm{OPT}}(IP2)}\le
c_1\)</span> and <span class="math inline">\(\frac{\mathop{\mathrm{OPT}}(LP2)}{\mathop{\mathrm{OPT}}(LP1)}\le
c_2\)</span>. Finally we will have something like this,</p>
<p><span class="math display">\[\begin{equation}
\mathop{\mathrm{OPT}}(IP1)\le c_1\mathop{\mathrm{OPT}}(IP2)= c_1
\mathop{\mathrm{OPT}}(LP2)\le c_1 c_2 \mathop{\mathrm{OPT}}(LP1)
\end{equation}\]</span></p>
<h2 data-number="3.1" id="minimum-k-edge-connected-spanning-subgraph"><span class="header-section-number">3.1</span> minimum <span class="math inline">\(k\)</span>-edge-connected spanning subgraph</h2>
<p>We want to prove that the integral gap for the following LP is 2.</p>
<p><span class="math display">\[\begin{align*}
LP1=\min&amp;   &amp; \sum_{e\in E} w(e&amp;)x_e    &amp; &amp;\\
s.t.&amp;       &amp; \sum_{e\in C} x_e&amp;\ge k    &amp; &amp;\forall
\text{cut $C$}\\
&amp;           &amp;  0\le x_e &amp;\le 1    &amp; &amp;\forall e\in E
\end{align*}\]</span></p>
<p>(Finding the minimum <span class="math inline">\(k\)</span>-edge-connected spanning subgraph of
<span class="math inline">\(G=(V,E)\)</span>)</p>
<p>Now we construct LP2. Consider the bidirection version of <span class="math inline">\(G\)</span>, denoted by <span class="math inline">\(D=(V,A)\)</span> where <span class="math inline">\(A=\{(u,v),(v,u) \quad \forall (u,v)\in
E\}\)</span>. Pick a special vertex <span class="math inline">\(r\)</span>.</p>
<p><span class="math display">\[\begin{align*}
LP2=\min&amp;   &amp; \sum_{e\in A} w(e)&amp;y_e            &amp; &amp;
\\
s.t.&amp;       &amp; \sum_{e\in \delta^+(S)} y_e&amp;\ge k &amp;
&amp;\forall S\subset V \land r\in S\\
&amp;          &amp; 0\le y_e &amp;\le
1                   &amp;  &amp;\forall e\in E
\end{align*}\]</span></p>
<p>(Finding min k-arborescence)</p>
<p>It is known that the polytope in LP2 is integral <span class="citation" data-cites="Schrijver2004">[<a href="#ref-Schrijver2004" role="doc-biblioref">2</a>]</span>. Given any
feasible solution of LP, for any edge <span class="math inline">\(e=(u,v)\in E\)</span> we set <span class="math inline">\(y_{(u,v)}=y_{(v,u)}=x_e\)</span>. Thus the optimum
of LP2 is no larger than <span class="math inline">\(2\mathop{\mathrm{OPT}}(LP)\)</span> since <span class="math inline">\(y\)</span> is always feasible.</p>
<p>On the other hand, given a feasible integral solution <span class="math inline">\(y\)</span> of LP2, we set <span class="math inline">\(x_e=1\)</span> if any orientation of <span class="math inline">\(e\)</span> is in <span class="math inline">\(y\)</span>. It is clear from the definition of LP2
that <span class="math inline">\(x_e\)</span> is a feasible integral
solution of LP. Hence, applying eq(1) proves that the integral gap of LP
is 2. (Note that in this example <span class="math inline">\(c_1=1\)</span> and <span class="math inline">\(c_2=2\)</span>.)</p>
<h1 data-number="4" id="notes"><span class="header-section-number">4</span> Notes</h1>
<p>There are many discussions about the integrality gap on cstheory.</p>
<ol type="1">
<li><a href="https://cstheory.stackexchange.com/questions/30984/exactly-solvable-but-non-trivial-integrality-gap" class="uri">https://cstheory.stackexchange.com/questions/30984/exactly-solvable-but-non-trivial-integrality-gap</a></li>
<li><a href="https://cstheory.stackexchange.com/questions/4915/integrality-gap-and-approximation-ratio" class="uri">https://cstheory.stackexchange.com/questions/4915/integrality-gap-and-approximation-ratio</a></li>
<li><a href="https://cstheory.stackexchange.com/questions/392/the-importance-of-integrality-gap" class="uri">https://cstheory.stackexchange.com/questions/392/the-importance-of-integrality-gap</a></li>
<li><a href="https://cstheory.stackexchange.com/questions/55188/randomized-rounding-schemes-that-depend-on-the-weights-in-the-lp-objective" class="uri">https://cstheory.stackexchange.com/questions/55188/randomized-rounding-schemes-that-depend-on-the-weights-in-the-lp-objective</a></li>
<li><a href="https://cstheory.stackexchange.com/questions/21060/optimization-problems-with-minimax-characterization-but-no-polynomial-time-algo" class="uri">https://cstheory.stackexchange.com/questions/21060/optimization-problems-with-minimax-characterization-but-no-polynomial-time-algo</a></li>
<li><a href="https://cstheory.stackexchange.com/questions/3871/minimum-maximal-solutions-of-lps" class="uri">https://cstheory.stackexchange.com/questions/3871/minimum-maximal-solutions-of-lps</a></li>
</ol>
<p>It seems that the integrality gap has a deep connection with hardness
of approximation. There are two kinds of problems that i find
particularly interesting.</p>
<ul>
<li>The LP has a relatively large gap, but some algorithm based on that
LP achieves a better approximation than the gap.(see <a href="http://www.cis.upenn.edu/~sanjeev/postscript/FOCS09_MaxMin.pdf">this
FOCSâ€™09 paper</a>)</li>
<li>The integrality gap is small (a constant), but approximation algs
based on the LP cannot do that good. (Zhiyi Huang gave a <a href="https://tcsuestc.com/2025/06/13/optimal-4-approximation-for-the-correlated-pandoras-problem/">talk
at UESTC</a> recently. <a href="https://arxiv.org/abs/2509.17029" class="uri">https://arxiv.org/abs/2509.17029</a> The correlated
Pandoraâ€™s problem has a natural LP formulation with gap <span class="math inline">\(&lt;4\)</span>, while <a href="https://tetali.math.gatech.edu/PUBLIS/mssc_final.pdf">it is
NP-hard</a> to aproximate it within a ratio of <span class="math inline">\(4-\epsilon\)</span>.)</li>
</ul>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-ding_complexity_2008" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">G.
Ding, L. Feng, W. Zang, The complexity of recognizing linear systems
with certain integrality properties, <em>Mathematical Programming</em>.
114 (2008) 321â€“334 <a href="https://doi.org/10.1007/s10107-007-0103-y">10.1007/s10107-007-0103-y</a>.</div>
</div>
<div id="ref-Schrijver2004" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">A.
Schrijver, <a href="http://books.google.com/books?hl=en&amp;lr=&amp;id=mqGeSQ6dJycC&amp;oi=fnd&amp;pg=PA1&amp;dq=Combinatorial+optimization+Polyhedra+and+Efficiency&amp;ots=xPOTKYfsKd&amp;sig=aH7tG7iKLIIljl5SMMx2yWNMAbM">Combinatorial
optimization <span>Polyhedra</span> and <span>Efficiency</span></a>,
Springer, 2004.</div>
</div>
<div id="ref-chekuri_lp_2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">C.
Chekuri, K. Quanrud, C. Xu, <span>LP</span> <span>Relaxation</span> and
<span>Tree</span> <span>Packing</span> for <span>Minimum</span>
$k$-<span>Cut</span>, <em>SIAM Journal on Discrete Mathematics</em>. 34
(2020) 1334â€“1353 <a href="https://doi.org/10.1137/19M1299359">10.1137/19M1299359</a>.</div>
</div>
<div id="ref-chalermsook_approximating_2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">P.
Chalermsook, C.-C. Huang, D. Nanongkai, T. Saranurak, P. Sukprasert, S.
Yingchareonthawornchai, Approximating
k-<span>Edge</span>-<span>Connected</span> <span>Spanning</span>
<span>Subgraphs</span> via a <span>Near</span>-<span>Linear</span>
<span>Time</span> <span>LP</span> <span>Solver</span>, in: <em>49th
<span>International</span> <span>Colloquium</span> on
<span>Automata</span>, <span>Languages</span>, and
<span>Programming</span> (<span>ICALP</span> 2022)</em>, Schloss
Dagstuhl â€“ Leibniz-Zentrum fÃ¼r Informatik, Dagstuhl, Germany, 2022: pp.
37:1â€“37:20 <a href="https://doi.org/10.4230/LIPIcs.ICALP.2022.37">10.4230/LIPIcs.ICALP.2022.37</a>.</div>
</div>
</div>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source on Github</a>.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="../images/ccbysa.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>