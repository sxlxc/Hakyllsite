<!doctype html>
<html lang="en">

<head>
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="googlebot" content="noindex">
    <title>A Fully Dynamic Reachability Algorithm for Directed Graphs with an Almost Linear Update Time</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/pygentize.css" />
    <link rel="stylesheet" href="../css/chao-theorems.css">
    <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
    <script>
        // page title
        document.addEventListener("DOMContentLoaded", function () {
            const hostname = window.location.hostname;
            document.title = document.title + " | " + hostname;
        });

        // pangu
        document.addEventListener('DOMContentLoaded', () => {
            pangu.autoSpacingPage();
        });

        // mathjax
        MathJax = {
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,        // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: false,        // true to enable speech generation
                        braille: false,       // true to enable Braille generation
                        assistiveMml: false,  // true to enable assistive MathML
                    }
                },
                enableMenu: false
            },
            output: {
                font: 'mathjax-fira',
                fontURL: '/mathjax-fira-font'
            },
            tex: {
                macros: {
                    floor: ["{\\left\\lfloor #1 \\right\\rfloor}", 1],
                    ceil: ["{\\left\\lceil #1 \\right\\rceil}", 1],
                    set: ["{\\left\\{ #1 \\right\\}}", 1],
                    norm: ["{\\left\\| #1 \\right\\|}", 1],
                    F: "{\\mathbb F}",
                    R: "{\\mathbb R}",
                    C: "{\\mathbb C}",
                    Z: "{\\mathbb Z}",
                    e: "{\\varepsilon}",
                    mex: "\\mathop{\\operatorname{mex}}",
                    lcm: "\\mathop{\\operatorname{lcm}}",
                    dist: "\\mathop{\\operatorname{dist}}",
                }
            }
        };
    </script>
    <script defer src="../mathjax/tex-chtml.js"></script>

</head>

<body>
    <div class="navbar-space">
        
    </div>
    <div class="text-space">
        <header class="no-print">
            <nav class="navbar">
                <a href="../">Home</a>
                <div class="navright">
                    <a href="../draft.html">Drafts</a>
                    <a href="../about.html">About</a>
                    <!-- <a href="/contact.html">Contact</a> -->
                    <!-- <a href="/archive.html">Archive</a> -->
                    <!-- <a href="/tags.html">Tags</a> -->
                </div>
            </nav>
        </header>

        <main role="main">
            <h1 class="pagetitle">A Fully Dynamic Reachability Algorithm for Directed Graphs with an Almost Linear Update Time</h1>
            <article>
    <section class="subtitle">
        
        
    </section>
    <section class="header">
        Posted on November 30, 2021
        
    </section>
    <div class="info">
        
            Tags: <a title="All pages tagged 'zzz'." href="../tags/zzz.html" rel="tag">zzz</a>
        
    </div>    
    <section>
        <p>在读的文章</p>
<p><a href="https://dl.acm.org/doi/pdf/10.1145/1007352.1007387">A Fully
Dynamic Reachability Algorithm for Directed Graphs with an Almost Linear
Update Time</a></p>
<h2 data-number="1" id="fully-dynamic-strong-connectivity-with-persistency"><span class="header-section-number">1</span> FULLY DYNAMIC STRONG CONNECTIVITY
WITH PERSISTENCY</h2>
<p>The algorithm handles each insert operation in <span class="math inline">\(O(mα(m, n))\)</span> worst-case time and each
deletion operation in <span class="math inline">\(O(mα(m, n) +
t)\)</span> amortized time, and each query in <span class="math inline">\(O(1)\)</span> time. The space complexity of the
algorithm is <span class="math inline">\(O(m+n)\)</span></p>
<p>插入和删除都可以对任意边集操作；每次插入会新建一个版本的图，删除则会从所有当前存在的版本中把要删除的边集删掉。</p>
<p><span class="math inline">\(Insert(E′): t \leftarrow t + 1 , E_t
\leftarrow E_{t−1} \cup E^′\)</span></p>
<p><span class="math inline">\(Delete(E′): E_i \leftarrow E_i − E^′ ,
\text{for} \quad 1 \leq i \leq t\)</span></p>
<p><span class="math inline">\(Query(u, v, i): \text{Are u and v in the
same component of the graph Gi?}\)</span></p>
<p><span class="math inline">\(G_i\)</span>’s SCC is either a SCC of
<span class="math inline">\(G_{i-1}\)</span> or a union of some SCCs of
<span class="math inline">\(G_{i-1}\)</span>;</p>
<p><span class="math inline">\(G_1,G_2,...,G_t\)</span>的所有SCC(不同G中相同SCC只记录一个)可以构成森林。叶子是单个的点。
The parent of a component w in the forest is the smallest component that
strictly contains w.</p>
<p>下面提出一个edge partition 的概念用来维护上述森林。</p>
<h3 data-number="1.1" id="dynamic-edge-partitioning"><span class="header-section-number">1.1</span> Dynamic edge partitioning:</h3>
<ol type="1">
<li><span class="math inline">\(H_i=\{(u,v) \in E_i | Query(u, v, i) ∧
(¬Query(u, v, i − 1) ∨ (u, v) \notin Ei−1) \}\)</span></li>
<li><span class="math inline">\(H_{t+1}=E_t\
\cup_{i=1}^{t}H_i\)</span></li>
</ol>
<p><span class="math inline">\(H_i\)</span>中的边是<span class="math inline">\(G_i\)</span>中的SCC里面的边，并且要么在<span class="math inline">\(G_{i-1}\)</span>中没有出现，要么在<span class="math inline">\(G_{i-1}\)</span>中是不同SCC之间的边。</p>
<p>用两个数组parent和version来记录森林中每个节点的父亲和最早出现的版本（version记录最早那一次插入操作后出现了这个scc）。</p>
<p>现在要查询<span class="math inline">\(G_i\)</span>中的两个点u,v是否在同一个SCC中，只需要在森林中查找u,v的LCA，如果version[LCA]小于等于i，说明u,v在同一个SCC中。（存在LCA说明在同一棵树，在某个版本u,v是在一个SCC中的，这个版本就是version[LCA]）</p>
<p>文中要使用<a href="https://dl.acm.org/doi/abs/10.1145/800061.808753">tarjan的LCA算法</a>均摊<span class="math inline">\(O(1)\)</span>的单次询问和<span class="math inline">\(O(n)\)</span>预处理（并查集使用路径压缩）。</p>
<h3 data-number="1.2" id="insert-delete-operation"><span class="header-section-number">1.2</span> Insert &amp; Delete
Operation</h3>
<p>初始化：<span class="math inline">\(G_0\)</span>是空图，森林是n个孤立的点，version都是0；</p>
<h4 data-number="1.2.1" id="insert"><span class="header-section-number">1.2.1</span> Insert:</h4>
<p>进行第t个插入操作，插入的边集是<span class="math inline">\(E'\)</span>：</p>
<p>首先根据 dynamic edge partitioning 的过程，<span class="math inline">\(H_t\)</span>已经存在并且里面有<span class="math inline">\(G_{t-1}\)</span>中SCC之间的边.</p>
<ol type="1">
<li><span class="math inline">\(H_t \leftarrow H_t \cup
E'\)</span></li>
<li>a temporary set of edges <span class="math inline">\(H'\)</span>
is created by contracting the endpoints of <span class="math inline">\(H_t\)</span> edges with respect to the components
of <span class="math inline">\(G_{t−1}\)</span>.</li>
<li>compute SCC in <span class="math inline">\(H'\)</span></li>
<li>for each SCC(denoted C) in <span class="math inline">\(H'\)</span>, union vertices in C, update
version and parent</li>
<li>move edges which shouldn’t in <span class="math inline">\(H_t\)</span> to <span class="math inline">\(H_{t+1}\)</span></li>
<li>preprocess LCA</li>
<li>t=t+1</li>
</ol>
<p>解释一下第二步：<span class="math inline">\(H'\leftarrow
\{(find(u),find(v))|(u,v)\in H_t \}\)</span> <span class="math inline">\(H_t\)</span>中的边是新加入的边和<span class="math inline">\(G_{t}\)</span>中SCC之间的边，同一个scc中的点可以看成是一个点（因为在联通性方面他们等价），于是直接用其中一个点来代替他们。如果在<span class="math inline">\(H'\)</span>中形成了SCC，那么每个SCC中的点就会形成一个大的SCC，再把他们union起来。思想就是使用并查集来维护不断插入边来维护SCC的过程。</p>
<h4 data-number="1.2.2" id="delete"><span class="header-section-number">1.2.2</span> Delete:</h4>
<p>delete操作十分暴力，直接破坏维护的整个并查集结构然后重新构建。</p>
<ol type="1">
<li>for each <span class="math inline">\(v\in V\)</span>, parent[<span class="math inline">\(v\)</span>]=null;</li>
<li>do insert k times (k versions)</li>
</ol>
<p>复杂度证明略。见论文。 （也提到了删除操作的<span class="math inline">\(O(mα(m, n) + t)\)</span> amortized time中的t是由于
要遍历t个<span class="math inline">\(H_i\)</span>集合造成的，但是由于每次至少插入一条边，t一定小于m，所以也可以去掉）</p>
<h2 data-number="2" id="identify-and-report-decompositions-of-scc"><span class="header-section-number">2</span> Identify and Report
Decompositions of SCC</h2>
<p>观察到无论是insert还是delete任意边集E，每个SCC在森林中的version不会减少。（insert只能增加version；delete一些边，相同的SCC只能在相同时间或者更晚形成。）</p>
<p>如果一个SCC在delete操作时被分开了，我们希望找到他在新的森林中对应的最大的儿子是哪些。</p>
<p>part操作：对于一个SCC（记为C），找到他子树中节点在delete操作之后的森林中的对应（记为集合S）。可以保证这些点的并集一定是C，但是不能保证S中的SCC都是最大的。</p>
<p>统计S中所有节点的父亲（如果没有父亲就跳过）记为集合T（其实是一个按version排列的优先队列）.每次取T中version最小的节点u，如果u的儿子都属于S，就把u的儿子从S中删除，S中加入u，且把u的父亲也加入T。</p>
<p>然后有split操作对于给定的delete前的SCC v和version
i，得到delete后分成了哪些version小于等于i的点：</p>
<ol type="1">
<li><span class="math inline">\(R\leftarrow Part(v)\)</span></li>
<li><span class="math inline">\(\text{while }\exists u\in R\text{ with
}version[u]\geq i\text{ do}\)</span></li>
<li><span class="math inline">\(\quad R \leftarrow R\cup
children[u]-\{u\}\)</span></li>
<li><span class="math inline">\(\text{return } R\)</span></li>
</ol>
<h2 data-number="3" id="decremental-maintenance-of-reachability-trees"><span class="header-section-number">3</span> DECREMENTAL MAINTENANCE OF
REACHABILITY TREES</h2>
<p>reachability
tree是用来维护对于某个点r的联通性的数据结构。每个节点是一个SCC，根节点是包含r的一个SCC，如果图中的某个SCC不在树中，说明从r不能到达这个scc中的节点。</p>
<blockquote>
<p>For every component w of the graph, the algorithm maintains a doubly
linked list active[w] that contains all the active vertices of the
component. A vertex v is active if it has uninspected inter-component
incoming edges.</p>
<p>For every <strong>active</strong> vertex v, the algorithm maintains a
doubly linked list in[v] containing all the uninspected inter-component
edges that enter v.</p>
<p>For every vertex v, <strong>active or inactive</strong>, the
algorithm maintains a doubly linked list out[v] containing all the edges
emanating from v.</p>
</blockquote>
<p>最开始所有边都是 uninspected，处理到一条边之后有两种情况： 1.
发现这条边没用，删掉 2. 这条边有用，变成 reachability tree
中的树边，保持 uninspected.</p>
<p>reachability tree 要保持这样的结构： &gt;If w is a component of G, v
&gt;is the first vertex in active[w], and u is the first &gt;vertex in
in[v], then (u, v) is the tree edge connecting &gt;component w to the
tree. In particular, &gt;if active[w] is empty, then w is not connected
to &gt;the tree and the vertices of w cannot be reached &gt;from r.</p>
<hr />
<p>为什么 in[v] 中只保存 inter-component 的边？</p>
<p>在SCC构成的森林中， intra-component
的边是自环，不可能成为树边，不要考虑他们。当 delete
操作之后，一个SCC中的 intra-component 边可能会变成 inter-component.
数据结构会维护这个部分。</p>
<p>当删除一些边的时候，要维护 reachability tree
就需要把删除边之后分裂的SCC找出、加入新的 inter-component
边，删除被删除的 inter-component 边。</p>
<p>但是这些操作可能会影响上面 reachability tree
要保持的结构，所以还需要再维护。</p>
<p>接下来只描述一下思想。</p>
<p>在 Identify and Report Decompositions of SCC
部分我们能得到任意一个SCC在 delete 操作之后会被 split
成新图中的哪些SCC。</p>
<p><span class="math display">\[w\rightarrow
\{w_1,w_2,...,w_j,...,w_l\}\]</span></p>
<p>可以得到一个被分裂出来的SCC的大小<span class="math inline">\(O(1)\)</span>和里面有哪些点<span class="math inline">\(O( | w_j | )\)</span>。</p>
<p>可以得到那些边从 intra-component 变成
inter-component.(比如被分开的SCC是<span class="math inline">\(G_i\)</span>中的，那么这一步找到的改变状态的边就是<span class="math inline">\(H_i\)</span>中被删除的边，根据 dynamic edge
partitioning 中<span class="math inline">\(H_i\)</span>的定义)</p>
<p>现在要维护出<span class="math inline">\(\{w_1,w_2,...,w_j,...,w_l\}\)</span>中每个SCC的active链表。</p>
<p><span class="math inline">\(\{w_1,w_2,...,w_j,...,w_l\}\)</span>中每个SCC的active链表中的点有两部分。一部分是由<span class="math inline">\(w\)</span>的active链表中的点继承下来的，另一部分是因为<span class="math inline">\(w\)</span>中的一些边被删掉了，某些点的入边从
intra-component 变成 inter-component ，导致这个点从 inactive 变为
active.</p>
<p>首先第二部分的点可以在更改边的状态时直接解决，这里不讨论。</p>
<p>第一部分的点有这样的做法。假设<span class="math inline">\(\{w_1,w_2,...,w_j,...,w_l\}\)</span>中这些SCC的大小是递减的。首先构建<span class="math inline">\(w_1\)</span>的active list，遍历<span class="math inline">\(w\)</span>的active
list中的点，把其中不属于a的都移动到其他某个<span class="math inline">\(w_k\)</span>的active
list中（注意分成的SCC是不可能有交集的）（这一步需要<span class="math inline">\(O(\sum_{j=2}^{l} | w_j | )\)</span>。</p>
<p>下面文中说： &gt;This makes a huge difference! If a vertex is moved
from one active list to another, the size of the component containing it
must have decreased by a factor of at least 2. Each vertex is therefore
moved at most <span class="math inline">\(\log_2n\)</span> times and the
total amount of time spent on constructing these lists is at most O(n
log n).</p>
<p><del>不是很懂为什么size会减半，复杂度为什么是O(nlogn)</del></p>
<p>我的理解出现了问题，，，通过不断分解来把点塞到更小的SCC里面。每次需要O(n)的时间来判断原来SCC中一个active的点该放到哪个分裂出的SCC中，SCC最多需要logn次就会变成点，因此是at
most O(n log n).</p>
<p>接下来 Reconnecting the tree after edge deletions</p>
<blockquote>
<p>Let W be a set containing all the new components with no incoming
tree edge, and all the old components that lost their incoming tree
edges. (If the root r is contained in a new component, this new
component is not added to W.) The set W can be easily constructed in O(
| W | ) time.</p>
</blockquote>
<p>删除一些边之后，原来的reachability
tree可能会变成森林。森林中的树根显然就是W中的SCC（根据定义）（也有可能是r现在所在的SCC，r原来所在的SCC因为删边被破坏了）。</p>
<p>现在，我们想把W中的这些树根连起来，重新组合成r的 reachability
tree</p>
<p>很容易想到利用上面早已构造好的 active 链表和 in 链表。</p>
<ol type="1">
<li><span class="math inline">\(\text{ for each }w \in W\)</span></li>
<li><span class="math inline">\(\quad \text{for each }u\in
active[w]\)</span></li>
<li><span class="math inline">\(\quad \quad \text{for each }v\in
in[u]\)</span></li>
<li><span class="math inline">\(\quad \quad \quad \text{if }
active[SCCNO[v]]!=null\text{ or }SCCNO[v]==SCCNO[r]\)</span></li>
<li><span class="math inline">\(\quad \quad \quad \quad \text{remove w
from W, this edge is a tentative tree edge}\)</span></li>
<li><span class="math inline">\(\quad \quad \quad
\text{else}\)</span></li>
<li><span class="math inline">\(\quad \quad \quad \quad \text{remove
that edge}\)</span></li>
</ol>
<p>A vertex v whose list in[v] becomes empty ceases to be active and is
removed from active[w].</p>
<p>如果在检查w的入边是否符合要求的时候发现并没有入边能符合要求，显然他是真的不行了，删边之后不会进入新的
reachability tree
了。但是还是要维护一下他的能到达的SCC（下面解释原因）。遍历他的出边（out[v]，v是w中的点)，如果out[v]中有边(v,u)
是 tentative tree edge，那需要把u所在的SCC加入W中。</p>
<p>这样做的原因：上面的标记 tentative tree edge
的步骤并没有考虑顺序，可能一些本来应该在新的 reachability tree
中的SCC直接连接到了某个已经不会在 reachability tree
里的SCC上面。为了防止漏掉SCC，要把不回进入新的 reachability tree 的SCC的
tentative tree edge 连接到的SCC重新加入W。</p>
<h2 data-number="4" id="an-almost-linear-fully-dynamic-reachability-algorithm"><span class="header-section-number">4</span> AN ALMOST LINEAR FULLY DYNAMIC
REACHABILITY ALGORITHM</h2>
<p>支持的操作：</p>
<ol type="1">
<li>插入：插入一些边（起始点或结束点都为同一个点）</li>
<li>删除：删除任意边集</li>
<li>询问：是否存在从u到v的路径</li>
</ol>
<p>每次插入操作都会围绕一个中心点v，那就为v建立两棵 reachability
tree，分别保存v能到达的点和能到达v的点（也相当于在原图和反图上建立上文的
reachability tree）这也是为什么上文 reachability tree
只需要处理删除操作。</p>
<p>查询是否存在从u到v的路径：检查是否存在这样一个w，使得u可以到达w（<span class="math inline">\(u\in T_{in}[w]\)</span>），而且w可以到达v（<span class="math inline">\(v\in T_{out}[w]\)</span>）. 这可以在<span class="math inline">\(O(n)\)</span>的时间内查找到。???</p>
<p><del>我思考了一下，不知道为何能在<span class="math inline">\(O(n)\)</span>回答询问。最坏情况要查找n个w，在reachability
tree中并不能在常数时间内回答树中是否存在某个点。有点迷惑。insert操作的更新是重新构建一个
reachability tree
，如果两棵树上存在同一个节点，能不能保证他们的子树是相同的？如果能，图中所有不同的SCC的级别难道不是O(nlogn)吗？</del></p>
<p>发现理解错了active[w]，查询u是否在以w为根的 reachability tree
中只需要判断w树中的active[c[u]]是否为空即可。</p>
    </section>
</article>

        </main>

        <footer class="no-print">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
            <a href="https://github.com/congyu711/Hakyllsite">Source on Github</a>.
            License <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 </a> <img src="https://licensebuttons.net/l/by-sa/4.0/88x31.png" alt="Creative Commons License" style="height: 12px; vertical-align: baseline;">

        </footer>
    </div>
</body>

</html>